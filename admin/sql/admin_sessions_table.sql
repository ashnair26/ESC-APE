-- Create admin_sessions table
CREATE TABLE IF NOT EXISTS public.admin_sessions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- Use standard auto-incrementing PK
    session_id UUID UNIQUE NOT NULL,
    admin_id UUID REFERENCES public.admin_users(id) ON DELETE CASCADE, -- Foreign key to admin_users
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    ip_address TEXT,
    user_agent TEXT
);

-- Add indexes for faster lookups
CREATE INDEX IF NOT EXISTS idx_admin_sessions_session_id ON public.admin_sessions(session_id);
CREATE INDEX IF NOT EXISTS idx_admin_sessions_admin_id ON public.admin_sessions(admin_id);
CREATE INDEX IF NOT EXISTS idx_admin_sessions_expires_at ON public.admin_sessions(expires_at);

-- Optional: Enable Row Level Security (RLS) if needed, though likely not necessary
-- if only accessed via service_role key in backend routes.
-- ALTER TABLE public.admin_sessions ENABLE ROW LEVEL SECURITY;
-- CREATE POLICY "Allow service_role access" ON public.admin_sessions FOR ALL USING (true);

-- Add comments for clarity
COMMENT ON TABLE public.admin_sessions IS 'Stores active admin user sessions for server-side validation.';
COMMENT ON COLUMN public.admin_sessions.session_id IS 'Unique identifier for the session, stored in JWT.';
COMMENT ON COLUMN public.admin_sessions.admin_id IS 'Foreign key referencing the admin user.';
COMMENT ON COLUMN public.admin_sessions.expires_at IS 'Timestamp when the session becomes invalid.';
COMMENT ON COLUMN public.admin_sessions.ip_address IS 'IP address associated with the session.';
COMMENT ON COLUMN public.admin_sessions.user_agent IS 'User agent string associated with the session.';
